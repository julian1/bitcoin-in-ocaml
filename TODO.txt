
leveldb, sqllite has transactions - we're going to need to use them, to prevent app/start
	stop without getting the data in.

----
inventory cannot be cleared when block is produced, because a chainstate reoganisation could
mean that block is orphaned. 

- indexing is multiple layered. 

- this is all fairly relational

bloc <- tx <- (160 address, btc address) (static and indepdent of chainstate, can all be written on block receipt)

utxo dynamic - (subject to chainstate reorgnisation) in memory, but probably requires 
		storing to disk	for responsive app starting/stopping
		- if sql then can just be a table. we add items to and remove on chain state reorgs.


whether a block is mainnet, testnet or orphaned is a dynamic property


to know if an address has funds - we have to find the associated tx, and check if it exists in
utxo. 

if we're going to store utxo on disk for faster loading, then we kind of need to also store
the chain state seq. (or at least get it synchronized)

btc address -> 160 address ->  
---

	- actually 160 hash -> btc address is a one way hash 
	- therefore to lookup unknown btc address, we will have to store btc addresses.




-------

- Need difficulty so that in case of forks - we know the main chain 
- Merckle tree to conform transaction set, is as the block header describes

- get the height included back in.

- manage uxtos - what is the desired outcome? have an index and offset into blocks.dat for each 
	uxto. if they are kept in mem 
		should try just scanning in memory first...

----

we can connect (http/or cli) to examine the read-only structures now, so
it's not really necessary to dump state everytime.

Ok, during runtime
	- blocks go in append-only log
	- leveldb for block and tx indexes - and can be regenerated

- heads should go in leveldb because 
	- writes should be fast 
	- and heads can be created by re-indexing
	- but we need serialization support?

actually we don't need sexp to serialize heads at all. just use

/head/hash1
/head/hash2

- peers are different in that they cannot be regenerated. actually they could
if we retained addr messages...


But what about the heads...
And the initial set of peers...
and the network type? 


